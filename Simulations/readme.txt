#README FOR SIMULATIONS


NOTE: the simulation code is not as documented as the main tool due to time constraints. Also not every script is still used, but remains included here for backup purposes and being able to reconstruct old results if necessary.


# How the code is setup and how to run the simulations


Each simulation type is in a separate file, denoted as simulations_xxx.py. There is a lot of overlap in the simulation code and therefore this setup is not best practice, but this was the quickest way to fix that each script does something similar, but still different. 

One simulation can be started from the code runSimulation.py. In this code, change the import of a simulation_xxx.py script to the desired simulation. As we ran our code on a HPC system, there are also .sh files that allow running the code in parallel.

Settings, related to the number of subclones to use in each sample, and also where to write the output data to, can be found in simulationSettings.py. This file is read by all the simulation scripts. 

To generate the figures in the paper, the results from the simulation scripts are processed by generateErrorBoxplots.py (for many figures, everything is in this file and can be (un)commented to generate figures as desired, more detailed can be found in the code itself), or generatePolyclonalSimulationFigures.py. 


List of which scripts were used to generate the simulation data for each simulation-related figure in the paper (see details in the paper on which noise levels and mu):

Figure 3:
A-D: the random LAF and SNV error is generated using simulations_randomLAFSNVs.py, running at 1 noise level of 0.
A-D, F, G, S5, S7, S9: simulations_permutations.py is run at multiple noise levels. Was started from runSimulation.sh.

Figure 4:
A, S10: simulations_mixedSamples.py was run for 1 noise level, and increasing the number of subclones and contamination fractions (see simulationSettings.py). Started from runSimulationsAndPermutationsOneMu.sh, with permutations disabled (only relevant for S8).


S6: simulations_permutations_realVAF.py (the name of this script may be slightly confusing, it models actual VAF instead of just binary values, but the binary values are still used by TargetClone so there is no difference from the other simulations generated by simulations_permutations.py. Basically, the simulations_permutations.py script is redundant after the introduction of this one, but was still included as some other results were generated with the old script). the real VAF is necessary for comparing to methods, as is done in S11). Started from runSimulationsAndPermutationsOneMu.sh, with permutations disabled (only relevant for S8).


S8: started from runSimulationsAndPermutationsOneMu.sh (repeated 100 times), with permutations enabled. For the simulations we used simulations_permutations.py 


S11: simulations_permutations_realVAF.py, run from runSimulation.sh to generate the TargetClone results. The output of MEDICC and LiCHeE are processed with methodComparator.py, which also generates the figure.

Non-simulation related figures were all generated from the main.py script as documented in the other readme on the main page. 

